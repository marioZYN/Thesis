#LyX 2.3 created this file. For more info see http://www.lyx.org/
\lyxformat 544
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\options openright
\use_default_options false
\master ../thesis.lyx
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding T1
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 11
\spacing single
\use_hyperref false
\papersize a4paper
\use_geometry false
\use_package amsmath 2
\use_package amssymb 2
\use_package cancel 1
\use_package esint 1
\use_package mathdots 0
\use_package mathtools 1
\use_package mhchem 0
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\use_minted 0
\index Indice
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style swiss
\dynamic_quotes 0
\papercolumns 1
\papersides 2
\paperpagestyle fancy
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
Image classification, detection and localization are two major challenges
 in compute vision field.
 In this chapter, we briefly introduce these three problems and the current
 state-of-art algorithms.
 Then we analyze how we can use these algorithms to solve our sea lion counting
 problem.
 
\end_layout

\begin_layout Section
Image classification
\end_layout

\begin_layout Standard
Image classification is the task of giving an input image and output the
 corresponding label.
 Before convolution neural network is used in image classification, we manually
 extract features from images and exploit these features for classifying
 images.
 It is a challenge, even for experts to design a feature extraction algorithm.
 Convolutional neural network(CNN) is a special kind of deep learning architectu
re used in computer vision.
 The convolution layer makes use of a set of learnable filters.
 A filter is used to detect the presence of specific features or patterns
 present in the original image.
 The filter is convolved across the width and height of the input image,
 and a dot product is computed to give an activation map.
 Different filters which detect different features are convolved with the
 input image and the activation maps are stacked together to form the input
 for the next layer.
 As we have more and more activation maps, we can consume too much memory
 and in order to solve this problem, pooling layers are used to reduce the
 dimension of the activation maps.
 There are two kinds of pooling layers: max pooling and average pooling.
 As the name states, max pooling keeps the maximum value within the filter
 and discards all the rest, while average pooling keeps the average value.
 By discarding the rest values, we reduce the dimension of the activation
 maps and thus reduce the number of parameters we need to learn.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/CNN.jpeg
	lyxscale 10

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
CNN architecture for image classification
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
After each convolution operation, an activation function is added to decide
 whether a certain neuron fires or not.
 There are different kinds of activation functions as illustrated in figure
 1.2 and they have different characteristics.
 Sigmoid functions squashes the output into a value between zero and one
 and it was the most popular activation function back in days since it has
 nice interpretation as a saturating 
\begin_inset Quotes cld
\end_inset

firing rate
\begin_inset Quotes crd
\end_inset

 of a neuron.
 However sigmoid activation function has three major problems:
\end_layout

\begin_layout Standard
1.
 Saturated neurons 
\begin_inset Quotes cld
\end_inset

kill
\begin_inset Quotes crd
\end_inset

 the gradients.
\end_layout

\begin_layout Standard
2.
 Sigmoid outputs are not zero-centered.
\end_layout

\begin_layout Standard
3.
 Exponential function is a bit compute expensive.
\end_layout

\begin_layout Standard
Later ReLU(Rectified Linear Unit) activation function is invented.
 ReLU activation function does not have saturation problem and while the
 largest gradient value for sigmoid function is 1/4, the gradient for ReLU
 function is 1 or 0.
 Theoretically ReLU activation function has larger convergence rate than
 sigmoid function.
 The problem for sigmoid function is that when we have a negative input
 value, the gradient is zero.
 It seems to behave like our neurons which can fire or not, but in reality
 this can create dead ReLU nodes.
 Since the value and gradient are all zero when the input value is negative,
 it can happen that some neurons can never fire again.
 This is called the 
\begin_inset Quotes cld
\end_inset

dead neuron phenomenon
\begin_inset Quotes crd
\end_inset

.
 In order to solve this problem, leaky ReLU is invented.
 Leaky ReLU does not have zero gradient at the negative part of the axis,
 but a small positive value, thus when necessary it can grow back to non
 zero, avoiding dead neuron problem.
 Nowadays leaky ReLU is the most common used activation function in deep
 learning architectures.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/activation functions.png
	lyxscale 10

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Activation functions
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The general idea for CNN architecture is to stack several convolution and
 pooling layers to extract features from images, then use fully connected
 layers to exploit these features for classification.
 By using CNN architecture we don't need to design feature extraction algorithm
 manually, instead we can use training images to make convolution filters
 to learn the weights itself.
 After fully connected layers, we pass the output through a soft-max layer
 to convert numbers between 0 and 1, giving probability of image being of
 a particular class.
 
\end_layout

\begin_layout Section
Image detection and localization
\end_layout

\begin_layout Standard
Image detection and localization is a more difficult task than image classificat
ion, because you not only need to classify the objects in the image, but
 also need to find the object location as well.
 Given an input image possibly containing multiple objects, we need to generate
 a bounding box around each object and classify the object type, as illustrated
 in figure 1.3.
 The general idea is to output the class label as well as the coordinates
 of the four corners of the bounding box.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/object detection.png
	lyxscale 10

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Object detection and localization
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Image detection and localization is a two-step problem, first we need to
 find which parts of the image may contain an object, second we need to
 classify each part.
 We call the region of image where may exist an object 
\begin_inset Quotes cld
\end_inset

region of interests
\begin_inset Quotes crd
\end_inset

(ROI).
 One straight forward way to find ROI is to use a slide window to generate
 all possible ROI.
 However this method needs to test many positions and scales which is time
 consuming in both training phase and testing phase.
 There exists various kinds of image detection and localization algorithms
 differing in ROI proposing technique.
\end_layout

\begin_layout Subsection
R-CNN
\end_layout

\begin_layout Standard
R-CNN is short for Regional Convolutional Neural Network.
 The basic idea is to use CNN to classify each ROI of the image.
 The pipeline for this algorithm is the following:
\end_layout

\begin_layout Enumerate
Train from scratch or download a pre-trained image classification model
 for ImageNet.
\end_layout

\begin_layout Enumerate
Fine-tune model for detection.
 Throw away the final fully connected layer and modify it according to domain
 dependent problem.
 
\end_layout

\begin_layout Enumerate
Extract region proposals for all images, and for each region, wrap it to
 CNN size and use CNN to classify its type.
 It can be a certain object or background.
 
\end_layout

\begin_layout Enumerate
Train one binary SVM per class to classify region features.
 
\end_layout

\begin_layout Enumerate
For each class, train a linear regression model to map from cached features
 to offsets to ground truth boxes to make up for 
\begin_inset Quotes cld
\end_inset

slightly wrong proposals
\begin_inset Quotes crd
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/R-CNN.png
	lyxscale 50

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
R-CNN architecture
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
In R-CNN algorithm, the region proposal method is independent from the algorithm
 itself, and we can use whatever region proposal algorithms we like.
 In the paper, the author suggests to use 
\begin_inset Quotes cld
\end_inset

selective search
\begin_inset Quotes crd
\end_inset

.
 Selective search is a greedy algorithm, starting from bottom-up segmentation
 merging regions at different scales.
 This method can find 
\begin_inset Quotes cld
\end_inset

blob-like
\begin_inset Quotes crd
\end_inset

 regions containing similar pixel values.
 For each image, there is around 2k regions of proposals.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/selective search.png
	lyxscale 40

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Selective search
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
R-CNN was the start-of-art algorithm for object detection in 2010.
 There are three major disadvantages for this algorithm, first of all it
 is slow at test time because it needs to run both the selective search
 and full forward path for each region proposal.
 Second, SVMs and regressors are post-hoc which can only be used in domain
 specific problem.
 For different problems we need to train SVMs and regressors from scratch.
 
\end_layout

\begin_layout Subsection
Fast R-CNN
\end_layout

\begin_layout Standard
Fast R-CNN is invented in order to break the bottleneck of R-CNN architecture.
 Instead of generating regions of proposals first and then use CNN to classify
 each region, fast R-CNN architecture first forwards the whole image into
 a CNN and then generates regions of proposals from the feature map.
 By swapping the order, fast R-CNN architecture shares computation of convolutio
nal layers between proposals for an image.
 After regions of proposals are generated, fast R-CNN architecture uses
 
\begin_inset Quotes cld
\end_inset

ROI Pooling
\begin_inset Quotes crd
\end_inset

 to wrap ROI into a predefined size.
 ROI pooling is actually a pooling operation with changeable filter size.
 This operation is necessary because we need to forward the feature vector
 through fully connected layers and the feature vector size is fixed once
 we set up the architecture.
 Fast R-CNN architecture can be trained end-to-end and we don't need to
 train separate modules like SVMs in R-CNN architecture.
 Fast R-CNN is a lot faster than R-CNN, according to the author, faster
 R-CNN training phase is 8 time faster than R-CNN and it only takes 0.32
 seconds to make inference at test time.
 However this inference time does not include generating regions of proposals,
 we still need to use other methods like selective search to find ROI.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/fast r-cnn.png
	lyxscale 20

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Fast R-CNN architecture
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Faster R-CNN
\end_layout

\begin_layout Standard
Faster R-CNN inserts a 
\begin_inset Quotes cld
\end_inset

Region Proposal Network
\begin_inset Quotes crd
\end_inset

(RPN) after the last convolutional layer of fast R-CNN and thus avoids using
 selective search to generate ROI.
 RPN is trainable to produce region proposals directly and there is no need
 for external region proposals.
 The rest of modules are the same as fast R-CNN.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename images/faster r-cnn.png
	lyxscale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Faster R-CNN architecture
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
RPN is a small network for classifying object or non-object and it can regress
 bounding box locations as well.
 A sliding window is used on the convolutional feature map and the position
 of the sliding window provides localization information with reference
 to the image.
 Box regression provides finer localization information with reference to
 this sliding window.
 Since we don't know the shape of objects in the image, in order to increase
 performance we use N anchor boxes at each location.
 Regression gives offsets from each anchor boxes to justify each ROI.
 Faster R-CNN is about ten times faster than fast R-CNN architecture and
 achieves similar performance result with respect to fast R-CNN.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status collapsed

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/RPN.png
	lyxscale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
RPN architecture
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/anchor.png
	lyxscale 30

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Anchor boxes
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Region proposal network
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Section
Counting objects by classification
\end_layout

\end_body
\end_document
